---
title: "SeSAMe Supplemental Vignette"
date: "`r BiocStyle::doc_date()`"
package: sesame
output: BiocStyle::html_document
fig_width: 6
fig_height: 5
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{"11. Supplemental"}
  %\VignetteEncoding{UTF-8}
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(sesame)
library(dplyr)
options(rmarkdown.html_vignette.check_title = FALSE)
```

This vignette book documents the SeSAMe package in full to supplement the
vignettes hosted on the Bioconductor.

# Preparation

**CRITICAL** As sesame and sesameData are under active development, this
  documentation is specific to the following version of sesame, sesameData and
  ExperimentHub:

```{r}
sapply(c("sesame","sesameData","ExperimentHub"),
    function(x) as.character(packageVersion(x)))
```

We recommend updating your R, ExperimentHub, sesameData and sesame to use this
documentation consistently. If you install directly from github, you need to
make sure the compatible ExperimentHub is installed.

**CRITICAL:** After a new installation, one needs to cache the associated
annotation data using the following command.
This needs to be done only once per SeSAMe installation/update.

```{r}
sesameDataCache()
```

This function caches the needed SeSAMe annotation for all the supported
platforms. SeSAMe annotation data is managed by the
[sesameData](https://tinyurl.com/58ny3rrt) package which uses the
[ExperimentHub](https://tinyurl.com/2p873tez) infrastructure.  You can find the
location of the cached annotation data on your local computer using:

```{r}
tools::R_user_dir("ExperimentHub", which="cache")
```

# openSesame components

## Read IDATs

The raw Infinium BeadChip data are stored in IDAT files. Each sample has
two IDAT files and they correspond to the red and green signal respectively.
Green and red files for the same samples should always share the same sample
name prefix.
For example, `204529320035_R06C01_Red.idat` and
`204529320035_R06C01_Grn.idat` correspond to the red and green signal
of one sample. In SeSAMe, we will use the **common prefix**,
i.e. `204529320035_R06C01`, to refer to that sample.
SeSAMe recognizes both the raw IDAT as well as gzipped IDATs which are common
for data stored in [GEO](https://www.ncbi.nlm.nih.gov/geo/).
For example, in addition to the example above, SeSAMe also recognizes
`GSM2178224_Red.idat.gz` and `GSM2178224_Grn.idat.gz`.

The function `readIDATpair` function reads in the signal intensity data from
the IDAT pairs. The function takes the common prefix as input and outputs a
`SigDF` object. The `SigDF` object is simply an R data.frame with rows
representing probes and columns representing different signal intensity and
probe annotations. The `SigDF` class will be discussed more in a separate
section below. Using the two examples above, one would run the following
commands.

```{r eval=FALSE}
sdf = readIDAT("idat_folder/204529320035_R06C01")  # Example 1
sdf = readIDAT("idat_folder/GSM2178224")           # Example 2
```

Note that SeSAMe automatically detects and matches up the green and red signal
files for the same sample. `SigDF` is and can be regarded and treated as a
regular `data.frame`:

```{r base3}
sdf = sesameDataGet('EPIC.1.SigDF') # an example SigDF
head(sdf) # peek into the internals
```

One can summarize resulting `SigDF` using the 'sesameQC_calcStats'
function (more QC can be found in the [quality control vignette](QC.html)).

```{r base4}
sesameQC_calcStats(sdf, "numProbes")
```

## Custom Arrays

If you are dealing with a custom-made array instead of the standard array
(MM285, EPIC, HM450 etc) supported natively by SeSAMe, you would need to
provide a manifest that describes the probe information. You should be able to
obtain the probe information manifest from the Illumina support website.  The
manifest should be formated as a data frame with four columns minimally:
`Probe_ID`, `M`, `U` and `col`. A optional `mask` column may also be included
as a default mask for the platform. The easiest way to format a
SeSAMe-compatible manifest is by following internal manifests for a
SeSAMe-supported platform. They can be retrieved with the `sesameDataGet`
function:

```{r}
mft = sesameDataGet("MM285.address")$ordering
```

The `col` is either `G` (which stands for Green) or `R` (which stands for Red)
or `2` (which stands for Infinium II designs).  For Infinium-II probes, the `M`
column and `col` column is left as `NA`.  For example, one can check that both
`M` and `col` columns are filled with the Infinium-I probes (in mouse array
this can be indicated by a `_[TBN][CON]1` suffix):

```{r}
head(mft[!is.na(mft$col),])
```

The last column `mask` is a logical vector that defines the default masking
behavior of SeSAMe for the platform (see below for discussion of
NA-masking). With the manifest, your data can be processed using the
`manifest=` option in `openSesame` or `readIDATpair` (one sample).

```{r eval = FALSE}
betas = openSesame("IDAT_dir", manifest = mft)
sdf = readIDATpair("your_sample_prefix", manifest = mft) # or one sample
```

## Search IDAT Prefixes

In most cases, we would be working with a folder that contains many IDATs. Here
is where the `searchIDATprefixes` function comes in useful. It lets us search
all the IDATs in a folder and its subfolders recursively. Combine this with the
R looping functions lets you process many IDATs without having to specify all
IDAT names. `searchIDATprefixes` returns a named vector of prefixes with
associated `Red` and `Grn` files, which can be given to `readIDATpair`:

```{r}
sdfs = lapply(searchIDATprefixes(system.file(
    "extdata/", package = "sesameData")), readIDATpair)
```

which returns a list of "SigDF"s. This is how the `openSesame` pipeline is
handling your data internally.

## $\beta$-value Extraction

DNA methylation level (aka the $\beta$ values) are defined as
$$\beta = M/(M+U)$$

$M$ represents the signal from methylated allele and $U$ represents the
unmethylated allele.  It can be retrieved calling the `getBetas` function with
the `SigDF` as input.  The output is a named vector with probe ID as names.
For example, the following commands read in one sample and convert it to
$\beta$ values.

```{r}
betas = getBetas(sdf) # retrieve beta values
head(betas)
```

**CRITICAL:** `getBetas` takes a single `SigDF` object as input instead of a
list of `SigDF`s. A common mistake is to `c`-merge multiple `SigDF`s. To
combine multiple `SigDF`s, one can use `list()` instead.  To process many
`SigDF`s, we should combine that with looping functions `lapply` or
`mclapply`s, or using the `openSesame` pipeline (see below).

$\beta$ values for Infinium-I probes can also be obtained by summing up the two
in-band channel and out-of-band channels. This rescues probes with SNP hitting
the extension base and hence switching color channel. More details can be found
in [Zhou et al 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).

# Preprocessing Functions

## Detection P-value

As mentioned above, experiment-dependent masking based on signal detection
p-values is effective in excluding artifactual methylation level reading
and probes with too much influence from signal background. We recommend the
`pOOBAH` algorithm that was based on Infinium-I probe out-of-band signal for
calibrating the distribution of the signal background:

```{r}
sum(sdf$mask)  # before pOOBAH, only quality mask
sum(pOOBAH(sdf)$mask) # after pOOBAH, expect more probes
sum(pOOBAH(resetMask(sdf))$mask) # pOOBAH-only masking
```

Sometimes one would want to calculation detection p-value without modifying the
mask.  For example, one may want to upload the p-values to GEO separately. In
those cases one can use the `return.pval` option and add pvalue-based mask
later.

```{r}
pvals = pOOBAH(sdf, return.pval=TRUE)
sdf2 = addMask(sdf, pvals > 0.05) # default, recommend between 0.05 and 0.2
```

## Background Subtraction

SeSAMe implements the background subtraction based on normal-exponential
deconvolution using out-of-band probes `noob`
([Triche et al. 2013](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3627582/))
and optionally with more aggressive subtraction (`scrub`). One can use
following $\beta$ value distribution plot to see the effect of background
subtraction. For example, the two (M and U) modes are further polarized.

```{r fig.width=5, fig.height=5, fig.keep="last"}
par(mfrow=c(2,1), mar=c(3,3,2,1))
sesameQC_plotBetaByDesign(sdf, main="Before", xlab="\beta")
sesameQC_plotBetaByDesign(noob(sdf), main="After", xlab="\beta")
```

## Dye Bias Correction

Dye bias refers to the difference in signal intensity between the two color
channel. SeSAMe offers two flavors of dye bias correction: linear scaling
(`dyeBiasCorr`) and nonlinear scaling (`dyeBiasCorrTypeINorm`). Linear scaling
equalize the mean of all probes from the two color channel.

```{r fig.width=7, fig.height=4, fig.keep="last", message=FALSE}
par(mfrow=c(1,2))
sesameQC_plotRedGrnQQ(dyeBiasCorr(sdf), main="Before") # linear correction
sesameQC_plotRedGrnQQ(dyeBiasNL(sdf), main="After")   # nonlinear correction
```

Residual dye bias can be corrected using nonlinear quantile interpolation with
Type-I probes. Under this correction, Infinium-I Red probes and Infinium-I Grn
probes have the same distribution of signal. Note that linear scaling does not
shift beta values of Type-I probes while nonlinear scaling does shift beta
values of Type-I probes.

## Channel Inference

Sometimes Infinium-I channel spec is inaccurate in the manifest. We can
infer the channel from data.

```{r}
sdf.InfICorrected = inferInfiniumIChannel(sdf, verbose=TRUE)
```

As one can see, most probes remain with the designated channel. A small
fraction of the probes is considered "channel-switching".

## Match Infinium-I/II

As we may've noticed, even with proper dye bias correction, there is still
remaining differences in $\beta$ value distribution between Infinium-I and
Infinium-II probes due to the signal tail inflation. One solution is to perform
ad-hoc quantile normalization. We provide a function similar to the BMIQ
algorithm with modifications (one-, two- and three-state mixture and Infinium-I
to II matching since Infinium-I is more often influenced by signal inflation
based on our experience) to match Infinium-I and Infinium-II beta value
distribution. We **do not** recommend the use of this (or any such methods) for
all data unless your data is known to be relatively well-behaving in
methylation distribution, for protection of real biological signal. This
function assumes Infinium-I/II probes are similar in $beta$ value distribution
in the unmethylated and methylated mode.

```{r fig.width=5, fig.height=5, fig.keep="last", message=FALSE}
par(mfrow=c(2,1), mar=c(3,3,2,1))
sesameQC_plotBetaByDesign(sdf, main="Before", xlab="\beta")
sesameQC_plotBetaByDesign(matchDesign(sdf), main="After", xlab="\beta")
```

# The SigDF Class

SeSAMe design includes a light-weight fullly-exposed infrastructure of the
internal signal intensities. Central to this infrastructure is the `SigDF` data
structure, which is a `data.frame` subclass. One can treat it like a regulator
`data.frame` with 7 specific columns, i.e., Probe_ID, MG, MR, UG, UR, col and
mask. The `col` column specifies the color channel and takes `G`, `R` and `2`.
The Infinium-I probes carry `G` and `R` in col to indicate the designed
color. This infrastructure is nimble to allow change of color channel, and mask
(the scope of usable probes) depending on the use of the array on different
species, strain, population etc. For example, the following data.frame
operation let you easily peek into the signal intensities.

```{r}
head(sdf[sdf$col != "2",])      # Infinium-I probes
head(sdf[sdf$col == "2",])      # Infinium-II probes
```

Sometimes, particularly with older arrays, there might exist a `controls`
attributes to contain the control probe information. In the new manifest, the
control probes will be parsed and included as regulator probes (except with a
`ctl` prefix in the probe ID). The control probe annotation can be found using
the following function:

```{r}
head(controls(sdf))
```

## Masking

If you call getBetas as is, you should have noticed that some of the beta
values show up having NA values. This NA-masking is controlled internally using
the `mask` column in `SigDF`. To check probes to be NA-masked in a `SigDF`, one
can use the `mask` function

```{r}
sum(sdf$mask)   # number of probes to be NA-masked
sum(is.na(getBetas(sdf))) # should be the same as above
```

Please note that `mask` in `SigDF` does not actually remove the probe reading
but only specify how SeSAMe currently views the measurement (as
unreliable). One can add more probes to the mask with the `addMask`
function. Other functions such as the detection p-value calculation (e.g.,
`pOOBAH`), also modifies `mask`. NA-masking influences other normalization and
preprocessing functions. Therefore one should have them set for the
preprocessing methods mentioned below. No mask is set by default unless done
through preprocessing functions. The `qualityMask` function does some
recommended experiment-independent masking. For example, probes with cross
hybridization or are influenced by common polymorphisms are masked using this
function. For more details of some of the maskings in `qualityMask` and
`listAvailableMasks(sdf)`, one can refer to [Zhou et
al. 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).

```{r, message=FALSE}
sdf = qualityMask(sesameDataGet('EPIC.1.SigDF'))
```

One can clear existing masking by the `resetMask` function.

```{r}
sum(sdf$mask)  # before resetting
sum(resetMask(sdf)$mask)  # after resetting, expect 0
```

The `getBetas` function can also ignore NA-masking when extracting beta
values by taking a `mask=FALSE` option:

```{r}
sum(is.na(getBetas(sdf, mask=FALSE)))  # expect 0
```

In all, most of the masking comes from two major sources:

1) **Experiment-dependent Probe Masking** based on signal detection p-value
([Zhou et al. 2018](https://www.ncbi.nlm.nih.gov/pubmed/30085201)). Probes with
p-value higher than a threshold (default: 0.05) are masked (see following for
detection p-value calculation using the `pOOBAH` method).

2) **Experiment-independent Probe Masking** due to design issues. This is
typically designated in the `mask` column of the manifest (see 
[Zhou et al. 2017](https://www.ncbi.nlm.nih.gov/pubmed/27924034)): This masking
supports EPIC, MM285, HM450 and HM27 and is turned on by default and can also be
explicitly added by the function `qualityMask`:

## Save SigDF as Plain Texts

`SigDF` can be written as and read from plain text file (e.g, tab-delimited
files and comma-delimited files) with the compliant column names (see above).

```{r}
tsv_file_path = sprintf("%s/sigdf.tsv", tempdir())
sdf_write_table(sdf, file=tsv_file_path, sep="\t", quote=FALSE) # save as tsv
sdf2 = sdf_read_table(tsv_file_path)                            # read back

csv_file_path = sprintf("%s/sigdf.csv", tempdir())
sdf_write_table(sdf, file=csv_file_path, sep=",") # save as csv
sdf2 = sdf_read_table(csv_file_path, sep=",")     # read back
```

# Interaction with Other Tools

Previously, the signal was implemented an S4 implementation in `SigSet`
complies with Bioconductor guidelines, and for backwards compatibility,
`SigSet` can be transformed to a `SigDF` using the `SigSetToSigDF` function
`sesame:::SigSetToSigDF(sset)`.

`SigSet`/`SigDF` can be converted back and forth from Minfi `RGChannelSet` in
multiple ways. One can sesamize a minfi `RGChannelSet` which returns a
`GenomicRatioSet`.  See [sesamize](https://github.com/zwdzwd/sesamize) for more
detail.

# Quality control plots

## QC Stats Bar plot

SeSAMe provides functions to create QC plots. Some functions takes sesameQC as
input while others directly plots the SigDF objects. For example, the
`sesameQC_plotBar` function takes a list of sesameQC objects and creates bar
plot for each metric calculated.

The fraction of detection failures are signs of masking due to variety of
reasons including failed detection, high background, putative low quality
probes etc. To compare samples in terms of detection success rate, one can use
the `sesameQC_plotBar` function in the following way:

```{r fig.height=3, fig.width=5}
sesameQC_plotBar(lapply(sdfs, sesameQC_calcStats, "detection"))
```

## Dye bias Q-Q plot

Dye bias is shown by an off-diagonal q-q plot of the red (x-axis) and green
signal (y-axis).

```{r fig.height=5, fig.width=5}
sesameQC_plotRedGrnQQ(sdf)
```

## Intensity-beta plot

Beta value is more influenced by signal background for probes with low signal
intensities. The following plot shows this dependency and the extent of probes
with low signal intensity.

```{r fig.height=5, fig.width=5}
sesameQC_plotIntensVsBetas(sdf)
```

## Genotype validation

Extra SNP allele frequencies can be obtained by summing up methylated and
umethylated alleles of color-channel-switching probes. These allele frequencies
can be combined with explicit SNP probes:

```{r}
head(getAFs(sdf)) # combined
head(getAFTypeIbySumAlleles(sdf)) # AFs from only color-channel-switching
```

SeSAMe can extract explicit and Infinium-I-derived SNPs to identify potential
sample swaps.

```{r fig.height=5, fig.width=5, message=FALSE}
sdfs <- sesameDataGet("EPIC.5.SigDF.normal")
sesameQC_plotHeatSNPs(sdfs[1:3])
```

One can also output the allele frequencies and output a VCF file with
genotypes. This requires additional SNP information (ref and alt alleles),
which can be downloaded using the following code:

```{r}
head(formatVCF(sdf))
```

One can output to actual VCF file with a header by `formatVCF(sdf,
vcf=path_to_vcf)`.

# Bisulfite conversion

Infinium platforms are intrinsically robust to incomplete bisulfite conversion
as non-converted probes would fail to hybridize to the target. Residual
incomplete bisulfite conversion can be quantified using GCT score based on
C/T-extension probes. Details of this method can be found in
[Zhou et al. 2017](https://academic.oup.com/nar/article/45/4/e22/2290930).
The closer the score to 1.0, the more complete the bisulfite conversion.

```{r}
sdf <- sesameDataGet('EPIC.1.SigDF')
bisConversionControl(sdf)
```

# Visualization

## Track View

SeSAMe provide utilities to view methylation reading in a track view.  Next, we
will demonstrate how to create track view with transcript position marked
focusing on a genomic region, a gene and specific probes.  Let's first load
example HM450 data

```{r model14}
betas <- sesameDataGet('HM450.10.TCGA.PAAD.normal')
```

### By Genomic Region

To visualize probes from arbitrary region, we will call `visualizeRegion`:

```{r model15, message=FALSE, fig.width=6, fig.height=5}
visualizeRegion(
    'chr19',10260000,10380000, betas, platform='HM450',
    show.probeNames = FALSE)
```

Zero to full methylation are displayed using the jet color scheme with blue
representing no methylation and red full methylation.

### By Gene Name

To visualize all probes from a gene, we will call `visualizeGene`

```{r model16, message=FALSE, fig.width=6, fig.height=5}
visualizeGene('DNMT1', betas, platform='HM450')
```

### By Probe ID

To visualize genome neighborhood using probe names, we will call
`visualizeProbes`:

```{r model17, message=FALSE, fig.width=6}
visualizeProbes(c("cg02382400", "cg03738669"), betas, platform='HM450')
```

# Session Info

```{r}
sessionInfo()
```
